Exp No.8:

a.)
#this code is correct(don't refer the drive one)

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.fftpack import dct, idct
# Load grayscale image
img = cv2.imread("/TE1.bmp", cv2.IMREAD_GRAYSCALE)
# Get image dimensions
h, w = img.shape
resized_img = cv2.resize(img,(8,8),interpolation=cv2.INTER_AREA)
cv2.imwrite("resized_image.tif",resized_img)

b.)
print(resized_img.shape)

c.)
plt.imshow(img,cmap='gray')

d.)
import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.fftpack import dct, idct

# Load grayscale image
from google.colab import files
print("Upload a grayscale image")
uploaded = files.upload()
image_name = list(uploaded.keys())[0]
img = cv2.imread(image_name, cv2.IMREAD_GRAYSCALE)

# Define block size
block_size = 8

# Standard JPEG Quantization matrix (Q50)
Q50 = np.array([[16, 11, 10, 16, 24, 40, 51, 61],
                [12, 12, 14, 19, 26, 58, 60, 55],
                [14, 13, 16, 24, 40, 57, 69, 56],
                [14, 17, 22, 29, 51, 87, 80, 62],
                [18, 22, 37, 56, 68, 109, 103, 77],
                [24, 35, 55, 64, 81, 104, 113, 92],
                [49, 64, 78, 87, 103, 121, 120, 101],
                [72, 92, 95, 98, 112, 100, 103, 99]])

# Generate Q10 (Strong Compression) and Q90 (High Quality)
def generate_quality_matrix(Q, quality):
  scale = 50 if quality >= 50 else 5000 / quality
  Q_new = np.floor((Q * scale + 50) / 100)
  return np.clip(Q_new, 1, 255)

Q10 = generate_quality_matrix(Q50, 10)
Q90 = generate_quality_matrix(Q50, 90)

# DCT and IDCT functions
def dct_2d(block):
  return dct(dct(block.T, norm='ortho').T, norm='ortho')

def idct_2d(block):
  return idct(idct(block.T, norm='ortho').T, norm='ortho')

# Compression function
def compress_image(img, Q):
  h, w = img.shape
  pad_h = (block_size - h % block_size) % block_size
  pad_w = (block_size - w % block_size) % block_size
  padded_img = np.pad(img, ((0, pad_h), (0, pad_w)), mode='constant', constant_values=0)
  padded_h, padded_w = padded_img.shape

  DCT_img = np.zeros((padded_h, padded_w), dtype=np.float32)
  IDCT_img = np.zeros((padded_h, padded_w), dtype=np.float32)
  reconstructed_img = np.zeros((padded_h, padded_w), dtype=np.uint8)

  for i in range(0, padded_h, block_size):
    for j in range(0, padded_w, block_size):
      block = padded_img[i:i+block_size, j:j+block_size].astype(np.float32) - 128
      D = dct_2d(block)
      C = np.round(D / Q)
      R = C * Q
      M_reconstructed = np.round(idct_2d(R)) + 128
      DCT_img[i:i+block_size, j:j+block_size] = D
      IDCT_img[i:i+block_size, j:j+block_size] = R
      reconstructed_img[i:i+block_size, j:j+block_size] = np.clip(M_reconstructed, 0, 255)

  return reconstructed_img[:h, :w], DCT_img[:h, :w], IDCT_img[:h, :w]

# Compress image using different quality levels
img_Q50 = compress_image(img, Q50)
img_Q10 = compress_image(img, Q10)
img_Q90 = compress_image(img, Q90)

# Display images
fig, ax = plt.subplots(2, 2, figsize=(10, 8))
ax[0][0].imshow(img, cmap='gray', vmin=0, vmax=255)
ax[0][0].set_title("Original Image")
ax[0][1].imshow(img_Q50[0], cmap='gray', vmin=0, vmax=255)
ax[0][1].set_title("Reconstructed Image (Q50)")
ax[1][0].imshow(img_Q10[0], cmap='gray', vmin=0, vmax=255)
ax[1][0].set_title("Reconstructed Image (Q10 - Strong Compression)")
ax[1][1].imshow(img_Q90[0], cmap='gray', vmin=0, vmax=255)
ax[1][1].set_title("Reconstructed Image (Q90 - High Quality)")
plt.tight_layout()
plt.show()

e.)
print("\nDifference with Q50 (5x5 block):")
print(np.abs(img.astype(np.float32) - img_Q50))
print("\nDifference with Q10 (5x5 block):")
print(np.abs(img.astype(np.float32) - img_Q10))
print("\nDifference with Q90 (5x5 block):")
print(np.abs(img.astype(np.float32) - img_Q90))

f.)
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

print("Upload a grayscale image")
uploaded = files.upload()
image_name = list(uploaded.keys())[0]  # Fixed typo: 'image name' -> 'image_name'
image = cv2.imread(image_name, cv2.IMREAD_GRAYSCALE)

# Define kernels
vertical_kernel = np.array([[-1, 2, -1],
                            [-1, 2, -1],
                            [-1, 2, -1]], dtype=np.float32)

horizontal_kernel = np.array([[-1, -1, -1],
                              [ 2,  2,  2],
                              [-1, -1, -1]], dtype=np.float32)

diag_45_kernel = np.array([[-1, -1,  2],
                           [-1,  2, -1],
                           [ 2, -1, -1]], dtype=np.float32)

diag_minus_45_kernel = np.array([[ 2, -1, -1],
                                 [-1,  2, -1],
                                 [-1, -1,  2]], dtype=np.float32)

# Manual convolution function
def apply_custom_filter(img, kernel):
    padded = np.pad(img, ((1, 1), (1, 1)), mode='constant', constant_values=0)
    output = np.zeros_like(img, dtype=np.float32)

    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            region = padded[i:i+3, j:j+3]
            output[i, j] = np.sum(region * kernel)

    output = np.clip(output, 0, 255).astype(np.uint8)
    return output

# Apply filters manually
vertical_lines = apply_custom_filter(image, vertical_kernel)
horizontal_lines = apply_custom_filter(image, horizontal_kernel)
diag_45_lines = apply_custom_filter(image, diag_45_kernel)
diag_minus_45_lines = apply_custom_filter(image, diag_minus_45_kernel)

# Display results
plt.figure(figsize=(12, 8))
plt.subplot(2, 3, 1)
plt.imshow(image, cmap='gray')
plt.title("Original Image")
plt.axis("off")
plt.subplot(2, 3, 2)
plt.imshow(vertical_lines, cmap='gray')
plt.title("Vertical Line Detection")
plt.axis("off")
plt.subplot(2, 3, 3)
plt.imshow(horizontal_lines, cmap='gray')
plt.title("Horizontal Line Detection")
plt.axis("off")
plt.subplot(2, 3, 4)
plt.imshow(diag_45_lines, cmap='gray')
plt.title("Diagonal 45° Line Detection")
plt.axis("off")
plt.subplot(2, 3, 5)
plt.imshow(diag_minus_45_lines, cmap='gray')
plt.title("Diagonal -45° Line Detection")
plt.axis("off")
plt.tight_layout()
plt.show()
